% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clip_to_ref_hull.R
\name{clip_to_ref_hull}
\alias{clip_to_ref_hull}
\title{Limit `data` to points contained within the m-dim convex hull of a reference set of data}
\usage{
clip_to_ref_hull(data, ref_data, print_all = TRUE)
}
\arguments{
\item{data}{numeric n1 x m data (n1 obs, m variables) that is coersable to matrix class}

\item{ref_data}{another m-dim dataset (n2 x m data, i.e., n2 obs, m variables) that is coersable to
 matrix class. This dataset is the reference dataset which creates the m-dim convex hull that
\code{data} is tested against.}

\item{print_all}{(\code{TRUE}, default) produces pairwise variable plots including points
in \code{data} that have been removed from the returned dataset.
\code{FALSE} only prints the remaining data points in \code{data} and the data
points in \code{data_ref}.}
}
\description{
Limit \code{data} to points contained within the m-dim convex hull of a reference set of data
}
\details{
\code{clip_to_ref_hull()} removes points from n1 x m \code{data} (n1 obs, m variables) that lie outside the
  m-dim convex hull of \code{ref_data}.

This function may be useful for containing generated/randomly data that do not extrapolate \code{ref_data}

Returned is the subset of \code{data} contained within the m-dim convex hull of \code{ref_data}

A set of pairwise plots of the m-dimensions including all \code{data} (subject to \code{print_all}
argument value) and \code{ref_data} is produced, with

\itemize{
  \item black points representing points of \code{ref_data}
  \item blue representing \code{data} within the m-dim convex hull of \code{ref_data}
}
}
\examples{
# ref_dat
# real data to imitate
library(dplyr)
data("fairclough", package = "deltacomp") # see github.com/tystan/deltacomp
fc3 <-
  fairclough \%>\%
  mutate(pa = lpa + mpa + vpa) \%>\%
  select(sed, pa, sleep)
summary(fc3)
fc3_ref <- simplex_to_ilr(as.matrix(fc3))
plot(fc3)
plot(fc3_ref)
# make compositions grid loosely based on summary(fc3)
# 10 min intervals
mygrid <- mk_simplex_grid(3, 10 / 1440, rm_edges = TRUE) * 1440 
colnames(mygrid) <- c("sed", "pa", "sleep")
mygrid <- as_tibble(mygrid)
head(mygrid)
kp_i <- 
  with(mygrid, as.logical(
    (  sed >= 300 &   sed <= 700) &
    (   pa >= 200 &    pa <= 500) &
    (sleep >= 400 & sleep <= 650) 
  ))
mygrid <- mygrid[kp_i, ]
mg_ilrs <- simplex_to_ilr(as.matrix(mg))
head(mg_ilrs)
remaining_rows <-clip_to_ref_hull(data = mg_ilrs, ref_data = fc3_ref)
}
\author{
Ty Stanford <tystan@gmail.com>
}
